#!/usr/bin/perl

use strict;
use warnings;
use OA::Indicator;
use OA::Indicator::DB;

my $oai = new OA::Indicator (verbose => 1);
my $comm = shift (@ARGV);
if (!$comm) {
    &usage ($oai);
}
if ($comm eq 'harvest') {
    my ($year, $type) = @ARGV;
    if (!$oai->valid_year ($year)) {
        if ($year) {
            &usage ($oai, 'invalid year: ' . $year);
        } else {
            &usage ($oai);
        }
    }
    if (!$oai->data_type ($type)) {
        if ($type) {
            &usage ($oai, 'unkmown data type: ' . $type);
        } else {
            &usage ($oai);
        }
    }
    if ($type eq 'bib') {
        foreach my $t (qw(romeo doaj bfi)) {
            if (!-e "/var/lib/oa-indicator/$year/$t") {
                warn ("fatal: please harvest " . $oai->data_type ($t) . " data for $year before harvesting bibliographic data\n");
                warn ("       oa-indicator harvest $t $year\n");
                exit (1);
            }
        }
        if (-e "/var/lib/oa-indicator/$year/$type") {
            &archive_source ($year, $type);
        }
        system ("/usr/sbin/oa-indicator-harvest-$type $year");
    } elsif ($type eq 'mxd') {
        foreach my $t (qw(bib)) {
            if (!-e "/var/lib/oa-indicator/$year/$t") {
                warn ("fatal: please harvest " . $oai->data_type ($t) . " data for $year before harvesting MXD data\n");
                warn ("       oa-indicator harvest $t $year\n");
                exit (1);
            }
        }
        if (-e "/var/lib/oa-indicator/$year/$type") {
            if (&confirm ($oai->data_type ($type), $year)) {
                &archive_source ($year, $type);
            } else {
                die ($oai->data_type ($type) . " re-harvest cancelled\n");
            }
        }
        system ("/usr/sbin/oa-indicator-harvest-$type $year");
    } else {
        if (-e "/var/lib/oa-indicator/$year/$type") {
            if (&confirm ($oai->data_type ($type), $year)) {
                &archive_source ($year, $type);
            } else {
                die ($oai->data_type ($type) . " re-harvest cancelled\n");
            }
        }
        system ("/usr/sbin/oa-indicator-harvest-$type $year");
    }
    exit (0);
}
if ($comm eq 'load') {
    my ($year, $run_type, @desc) = @ARGV;
    if (!$oai->valid_year ($year)) {
        if ($year) {
            &usage ($oai, 'invalid year: ' . $year);
        } else {
            &usage ($oai);
        }
    }
    if (!$oai->run_type ($run_type)) {
        if ($run_type) {
            &usage ($oai, 'invalid run type: ' . $run_type);
        } else {
            &usage ($oai);
        }
    }
    my $desc = join (' ', @desc);
    $oai->log_main ('i', "starting load segment");
    if (system ("/usr/sbin/oa-indicator-load $year $run_type begin $desc")) {
        $oai->log_main ('f', "failed to begin load statement with year: $year and run type: $run_type");
        exit (1);
    }
    my $db = new OA::Indicator::DB ();
    $db->open ($year, $run_type);
    my $logdir = '/var/lib/oa-indicator/log/' . $db->id;
    mkdir ($logdir, 0775);
    system ("chmod 02775 $logdir");
    $oai->log_file ("$logdir/load.log");
    $oai->log ('i', 'new data load');
    $oai->log ('i', 'loading bfi');
    if (system ("/usr/sbin/oa-indicator-load $year $run_type bfi")) {
        $oai->log ('f', "failed to load bfi: see $logdir/load_bfi.log");
        system ("/usr/sbin/oa-indicator-load $year $run_type end 0 'error loading bfi'");
    }
    if (system ("/usr/sbin/oa-indicator-load $year $run_type doaj")) {
        $oai->log ('f', "failed to load doaj: see $logdir/load_doaj.log");
        system ("/usr/sbin/oa-indicator-load $year $run_type end 0 'error loading doaj'");
    }
    if (system ("/usr/sbin/oa-indicator-load $year $run_type mxd")) {
        $oai->log ('f', "failed to load doaj: see $logdir/load_mxd.log");
        system ("/usr/sbin/oa-indicator-load $year $run_type end 0 'error loading mxd'");
    }
    if (system ("/usr/sbin/oa-indicator-load $year $run_type romeo")) {
        $oai->log ('f', "failed to load doaj: see $logdir/load_romeo.log");
        system ("/usr/sbin/oa-indicator-load $year $run_type end 0 'error loading romeo'");
    }
    if (system ("/usr/sbin/oa-indicator-load $year $run_type bib")) {
        $oai->log ('f', "failed to load doaj: see $logdir/load_bib.log");
        system ("/usr/sbin/oa-indicator-load $year $run_type end 0 'error loading bib'");
    }
    system ("/usr/sbin/oa-indicator-load $year $run_type end 1 success");
    exit (0);
}
if ($comm eq 'segment') {
    my ($year, $run_type, $name) = @ARGV;
    if ($year) {
        if (!$oai->valid_year ($year)) {
            &usage ($oai, 'invalid year: ' . $year);
        }
    } else {
        &usage ($oai);
    }
    if ($run_type) {
        if ($run_type !~ m/^(devel|test|prod)$/) {
            &usage ($oai, 'invalid run type: ' . $run_type);
        }
    } else {
        &usage ($oai);
    }
    $oai->arg ('year', $year);
    my $db = new OA::Indicator::DB ();
    $db->open ($year, $run_type);
    if (!$db->segment_validate ($name)) {
        &usage ($oai, "fatal: invalid segment: $name, valid segments are: " . join (' | ', $db->segments));
    }
    $oai->log_file ("/var/lib/oa-indicator/$year/$name.log");
    $oai->log_main ('i', "starting segment $name, see /var/lib/oa-indicator/$year/$name.log for details");
    if ($name eq 'scope') {
        require OA::Indicator::Segments::Scope;
        $db->segment_start ('scope');
        my $seg = new OA::Indicator::Segments::Scope ($db->db (), $oai);
        if ($seg->process ()) {
            $db->segment_end ('scope', 1);
        } else {
            $db->segment_end ('scope', 0);
        }
        exit (0);
    }
    if ($name eq 'screen') {
        require OA::Indicator::Segments::Screen;
        $db->segment_start ('screen');
        my $seg = new OA::Indicator::Segments::Screen ($db->db (), $oai);
        if ($seg->process ()) {
            $db->segment_end ('screen', 1);
        } else {
            $db->segment_end ('screen', 0);
        }
        exit (0);
    }
    if ($name eq 'fetch') {
        require OA::Indicator::Segments::Fetch;
        $db->segment_start ('fetch');
        my $seg = new OA::Indicator::Segments::Fetch ($db->db (), $oai);
        if ($seg->process ()) {
            $db->segment_end ('fetch', 1);
        } else {
            $db->segment_end ('fetch', 0);
        }
        exit (0);
    }
    if ($name eq 'classify') {
        require OA::Indicator::Segments::Classify;
        $db->segment_start ('classify');
        my $seg = new OA::Indicator::Segments::Classify ($db->db (), $oai);
        if ($seg->process ()) {
            $db->segment_end ('classify', 1);
        } else {
            $db->segment_end ('classify', 0);
        }
        exit (0);
    }
    die ("un-implemented segment: $name\n");
}
if ($comm eq 'close') {
    my ($year, $run_type, $name) = @ARGV;
    if ($year) {
        if (!$oai->valid_year ($year)) {
            &usage ($oai, 'invalid year: ' . $year);
        }
    } else {
        &usage ($oai);
    }
    if ($run_type) {
        if ($run_type !~ m/^(devel|test|prod)$/) {
            &usage ($oai, 'invalid run type: ' . $run_type);
        }
    } else {
        &usage ($oai);
    }
    my $db = new OA::Indicator::DB ();
    $db->open ($year, $run_type);
#   FIX add real success checks
    $db->close (1);
    exit (0);
}
&usage ($oai, "unknown command: $comm");
exit (0);

sub confirm
{
    my ($type, $year) = @_;
    my ($ans);

    print (STDERR "$type data already exists for $year, please confirm that you want to replace that data [N/y]: ");
    chomp ($ans = <STDIN>);
    if ($ans =~ m/^y(es)?$/i) {
        return (1);
    } else {
        return (0);
    }
}

sub archive_source
{
    my ($year, $type) = @_;
    my $n = '01';

    while ((-e "/var/lib/oa-indicator/$year/$type.$n") ||
           (-e "/var/lib/oa-indicator/$year/$type.$n.tar") ||
           (-e "/var/lib/oa-indicator/$year/$type.$n.tar.gz")) {
        $n = sprintf ('%02d', $n + 1);
    }
    if (system ("cd /var/lib/oa-indicator/$year; tar cf $type.$n.tar $type")) {
        die ("fatal: failed to tar existing source:\n" .
             "       cd /var/lib/oa-indicator/$year; tar cf $type.$n.tar $type\n");
    }
    if (system ("gzip -9 /var/lib/oa-indicator/$year/$type.$n.tar")) {
        die ("fatal: failed to gzip existing source:\n" .
             "       gzip /var/lib/oa-indicator/$year/$type.$n.tar\n");
    }
    if (system ("rm -rf /var/lib/oa-indicator/$year/$type")) {
        die ("fatal: failed to remove existing source after archiving:\n" .
             "       rm -rf /var/lib/oa-indicator/$year/$type\n");
    }
}

sub usage
{
    my ($oai, $msg) = @_;

    if ($msg) {
        warn ("\n$msg\n");
    }
    warn ('usage: ao-indicator harvest <year> <' . join (' | ', $oai->data_types ()) . ">\n");
    warn ('       ao-indicator load    <year> <' . join (' | ', $oai->run_types ()) . "> [description])\n");
    warn ('       ao-indicator segment <year> <' . join (' | ', $oai->run_types ()) . '> <' . join (' | ', $oai->segments ()) . ">\n");
    warn ('       ao-indicator close   <year> <' . join (' | ', $oai->run_types ()) . ">\n\n");
    warn ("       valid years are " . $oai->valid_year_range () . "\n\n");
    exit (1);
}

