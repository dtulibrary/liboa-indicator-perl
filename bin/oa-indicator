#!/usr/bin/perl

use strict;
use warnings;
use OA::Indicator;
use OA::Indicator::DB;

my $oai = new OA::Indicator (verbose => 1);
my $comm = shift (@ARGV);
if (!$comm) {
    &usage ($oai);
}
if ($comm eq 'harvest') {
    my ($year, $type) = @ARGV;
    if (!$oai->valid_year ($year)) {
        if ($year) {
            &usage ($oai, 'invalid year: ' . $year);
        } else {
            &usage ($oai);
        }
    }
    if (!$oai->data_type ($type)) {
        if ($type) {
            &usage ($oai, 'unkmown data type: ' . $type);
        } else {
            &usage ($oai);
        }
    }
    if ($type eq 'bib') {
        foreach my $t (qw(romeo doaj bfi)) {
            if (!-e "/var/lib/oa-indicator/$year/$t") {
                die ("fatal: please harvest " . $oai->data_type ($t) . " data for $year before harvesting bibliographic data\n");
                warn ("      oa-indicator harvest $t $year\n");
                exit (1);
            }
        }
        if (-e "/var/lib/oa-indicator/$year/$type") {
            &archive_source ($year, $type);
        }
        system ("/usr/sbin/oa-indicator-harvest-$type $year");
    } elsif ($type eq 'mxd') {
        foreach my $t (qw(bib)) {
            if (!-e "/var/lib/oa-indicator/$year/$t") {
                die ("fatal: please harvest " . $oai->data_type ($t) . " data for $year before harvesting MXD data\n");
                warn ("      oa-indicator harvest $t $year\n");
                exit (1);
            }
        }
        if (-e "/var/lib/oa-indicator/$year/$type") {
            if (&confirm ($oai->data_type ($type), $year)) {
                &archive_source ($year, $type);
            } else {
                die ($oai->data_type ($type) . " re-harvest cancelled\n");
            }
        }
        system ("/usr/sbin/oa-indicator-harvest-$type $year");
    } else {
        if (-e "/var/lib/oa-indicator/$year/$type") {
            if (&confirm ($oai->data_type ($type), $year)) {
                &archive_source ($year, $type);
            } else {
                die ($oai->data_type ($type) . " re-harvest cancelled\n");
            }
        }
        system ("/usr/sbin/oa-indicator-harvest-$type $year");
    }
    exit (0);
}
if ($comm eq 'load') {
    my ($year, $run_type, @desc) = @ARGV;
    if ($year !~ m/201[3-9]/) {
        if ($year) {
            &usage ($oai, 'invalid year: ' . $year);
        } else {
            &usage ($oai);
        }
    }
    if ($run_type !~ m/^(devel|test|prod)$/) {
        if ($run_type) {
            &usage ($oai, 'invalid run type: ' . $run_type);
        } else {
            &usage ($oai);
        }
    }
    my $desc = join (' ', @desc);
    system ("/usr/sbin/oa-indicator-load $year $run_type begin $desc");
    system ("/usr/sbin/oa-indicator-load $year $run_type bfi");
#   system ("/usr/sbin/oa-indicator-load $year $run_type doaj");
    system ("/usr/sbin/oa-indicator-load $year $run_type mxd");
    system ("/usr/sbin/oa-indicator-load $year $run_type romeo");
    system ("/usr/sbin/oa-indicator-load $year $run_type bib");
#   FIX - add error checks and success and errors to end call
    system ("/usr/sbin/oa-indicator-load $year $run_type end");
    exit (0);
}
if ($comm eq 'segment') {
    my ($year, $run_type, $name) = @ARGV;
    if ($year) {
        if (!$oai->valid_year ($year)) {
            &usage ($oai, 'invalid year: ' . $year);
        }
    } else {
        &usage ($oai);
    }
    if ($run_type) {
        if ($run_type !~ m/^(devel|test|prod)$/) {
            &usage ($oai, 'invalid run type: ' . $run_type);
        }
    } else {
        &usage ($oai);
    }
    my $db = new OA::Indicator::DB ($year, $run_type);
    $db->open ();
    if (!$db->segment_validate ($name)) {
        &usage ($oai, "fatal: invalid segment: $name, valid segments are: " . join (' | ', $db->segments));
    }
    $oai->log_file ("/var/lib/oa-indicator/$year/$name.log");
    $oai->log_main ('i', "starting segment $name, see /var/lib/oa-indicator/$year/$name.log for details");
    if ($name eq 'scope') {
        require OA::Indicator::Segments::Scope;
        $db->segment_start ('scope');
        my $seg = new OA::Indicator::Segments::Scope ($db->db (), $oai);
        if ($seg->process ()) {
            $db->segment_end ('scope', 1);
        } else {
            $db->segment_end ('scope', 0);
        }
        exit (0);
    }
    if ($name eq 'screen') {
        require OA::Indicator::Segments::Screen;
        $db->segment_start ('screen');
        my $seg = new OA::Indicator::Segments::Screen ($db->db (), $oai);
        if ($seg->process ()) {
            $db->segment_end ('screen', 1);
        } else {
            $db->segment_end ('screen', 0);
        }
        exit (0);
    }
    if ($name eq 'fetch') {
        require OA::Indicator::Segments::Fetch;
        $db->segment_start ('fetch');
        my $seg = new OA::Indicator::Segments::Fetch ($db->db (), $oai);
        if ($seg->process ()) {
            $db->segment_end ('fetch', 1);
        } else {
            $db->segment_end ('fetch', 0);
        }
        exit (0);
    }
    die ("un-implemented segment: $name\n");
}
&usage ($oai, "unknown command: $comm");
exit (0);

sub confirm
{
    my ($type, $year) = @_;
    my ($ans);

    print (STDERR "$type data already exists for $year, please confirm that you want to replace that data [N/y]: ");
    chomp ($ans = <STDIN>);
    if ($ans =~ m/^y(es)?$/i) {
        return (1);
    } else {
        return (0);
    }
}

sub archive_source
{
    my ($year, $type) = @_;
    my $n = '01';

    while ((-e "/var/lib/oa-indicator/$year/$type.$n") ||
           (-e "/var/lib/oa-indicator/$year/$type.$n.tar") ||
           (-e "/var/lib/oa-indicator/$year/$type.$n.tar.gz")) {
        $n = sprintf ('%02d', $n + 1);
    }
    if (system ("cd /var/lib/oa-indicator/$year; tar cf $type.$n.tar $type")) {
        die ("fatal: failed to tar existing source:\n" .
             "       cd /var/lib/oa-indicator/$year; tar cf $type.$n.tar $type\n");
    }
    if (system ("gzip -9 /var/lib/oa-indicator/$year/$type.$n.tar")) {
        die ("fatal: failed to gzip existing source:\n" .
             "       gzip /var/lib/oa-indicator/$year/$type.$n.tar\n");
    }
    if (system ("rm -rf /var/lib/oa-indicator/$year/$type")) {
        die ("fatal: failed to remove existing source after archiving:\n" .
             "       rm -rf /var/lib/oa-indicator/$year/$type\n");
    }
}

sub usage
{
    my ($oai, $msg) = @_;

    if ($msg) {
        warn ("\n$msg\n");
    }
    warn ('usage: ao-indicator harvest <year> <' . join (' | ', $oai->data_type ()) . ">\n");
    warn ("       ao-indicator load    <year> <devel | test | prod> [description])\n");
    warn ("       ao-indicator segment <year> <devel | test | prod> <segment-name>\n\n");
    warn ("       valid years are " . $oai->valid_year_range () . "\n\n");
    exit (1);
}

